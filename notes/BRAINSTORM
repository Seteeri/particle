https://news.ycombinator.com/item?id=14482988
https://stackoverflow.com/questions/24839857/wireframe-shader-issue-with-barycentric-coordinates-when-using-shared-vertices
https://catlikecoding.com/unity/tutorials/advanced-rendering/flat-and-wireframe-shading
https://www.reddit.com/r/opengl/comments/3yrv79/simplistic_texture_less_tronlike_3d_with_opengl/
https://academia.stackexchange.com/questions/109/is-there-any-efficient-non-linear-note-taking-software
https://softwareengineering.stackexchange.com/questions/224146/how-has-an-increase-in-the-complexity-of-systems-affected-successive-generations/224152

Presentation

* Problems in Current Computing World
  * Userland and web browsers becoming increasingly complicated
  making it difficult to understand
    * How many frameworks, libraries, technologies are used in a modern website?
  * Computing power increasing but software not taking advantage
* Emacs and Vim
  * The Good
    * Good for pure text UI and limited/constrained environments
    * Highly efficient
    * Tailored to specific workflow
  * The Bad
    * Both systems have high initial learning curve
    * Emacs chords lead to RSI
    * No robust graphical support beyond text
    * Synchronous design - no threading etc.
      * Unresponsive UI when running intensive operations
    * Both lack discoverability and are not newbie friendly, at all
      * Important to get users for sustainability and innovation
    * Assume new users have high computing proficiency so OOB XP competely neglected
      * Assumes users build system from bottom-up rather than top-down perspective
      * Spacemacs et al provide solutions but still not perfect
      * Upstream needs to endorse an official OOB configuration
  * Linux Userland Fragmentation
    * Systemd designed to solve sysadmin problems
    * Wayland designed to fix X11 problems
    * Maybe a userland designed for single-user systems
    * Applications continuously reinvent the same desktop paradigm and functionality
      * Change for the sake of change is not progress

* Possible Solutions
  * Lisp
    * Power never fully realized when using text editing
      * More graphical power today
    * Lisp power lost when compiled
    * Interpreting forgotten
      * Popularity of python and C integration shows feasible with todays computing speeds
  * End-user needs growingly different than sysadmin needs
    * Different UI paradigms
    * More mobile
    * Need better ways to transfer information between systems


* Turbo nerd
* ubersicht


################################################################################

https://news.ycombinator.com/item?id=15466124

No.

I expect this will be a fairly controversial comment, so I want to preface this by saying that I'm a big Lisp fan (just look at my handle). Lisp is my favorite programming language. I've been using it for nearly forty years. My first Lisp was P-Lisp on an Apple II in 1980. And I worked on Symbolics Lisp machines in the 1990s. They were very cool, but there's a reason they failed: general-purpose computing is infrastructure, and the economics of infrastructure are such that having a single standard is the most economical solution, even if that standard is sub-optimal. For better or worse, the standard for general-purpose computing is the C machine.

Because it's general-purpose you certainly can run Lisp on a C machine (just as you could run C on a Lisp machine). You can even do this at the system level. But Lisp will always be at a disadvantage because the hardware is optimized for C. Because of this, C will always win at the system level because at that level performance matters.

But that in and of itself is not the determining factor. The determining factor is the infrastructure that has grown up around the C machine in the last few decades. There is an enormous amount of work that has gone into building compilers, network stacks, data interchange formats, libraries, etc. etc. and they are all optimized for C. For Lisp to be competitive at the system level, nearly all of this infrastructure would have to be re-created, and that is not going to happen. Even with the enormous productivity advantages that Lisp has over C (and they really are enormous) this is not enough to overcome the economic advantages that C has by virtue of being the entrenched standard.

The way Lisp can still win in today's world is not by trying to replace C on the system level, but by "embracing and extending" C at the application level. I use Clozure Common Lisp. It has an Objective-C bridge, so I can call ObjC functions as if they were Lisp functions. There is no reason for me to know or care that these functions are actually written in C (except insofar as I have to be a little bit careful about memory management when I call C functions from Lisp) and so using Lisp in this way still gives me a huge lever that is economically viable even in today's world. I have web servers in production running in CCL on Linux, and it's a huge win. I can spin up a new web app on AWS in just a few minutes from a standing start. It's a Lisp machine, but at the application level, not the system level. My kernel (Linux) and web front end (nginx) are written in C, but that doesn't impact me at all because they are written by someone else. I just treat them as black boxes.

I don't want to denigrate ChrysaLisp in any way. It's tremendously cool. But cool is not enough to win in the real world.

[UPDATE] ChrysaLisp is actually doing the Right Thing with respect to its GUI by
 using a C-library (SDL). But it's trying to re-invent the compiler wheel (and
 the language design wheel) so that it can run on bare metal and "grow up to be
 a real Lisp machine" some day, and I think that aspect of the project is a
 fool's errand. There are already many Lisps that can run on bare metal (ECL was
  specifically designed for that). None of them have succeeding in displacing C,
  and I believe none ever will because the economic hurdles are insurmountable.

################################################################################

(defun read-64 (buf)
  (let ((u 0))
    (setf (ldb (byte 8 56) u) (aref buf 7))
    (setf (ldb (byte 8 48) u) (aref buf 6))
    (setf (ldb (byte 8 40) u) (aref buf 5))
    (setf (ldb (byte 8 32) u) (aref buf 4))
    (setf (ldb (byte 8 24) u) (aref buf 3))
    (setf (ldb (byte 8 16) u) (aref buf 2))
    (setf (ldb (byte 8 8) u) (aref buf 1))
    (setf (ldb (byte 8 0) u) (aref buf 0))
    u))

(defun read-32 (buf)
   (let ((u 0))
    (setf (ldb (byte 8 24) u) (aref buf 3))
    (setf (ldb (byte 8 16) u) (aref buf 2))
    (setf (ldb (byte 8 8) u) (aref buf 1))
    (setf (ldb (byte 8 0) u) (aref buf 0))
    u))

(defun read-16 (buf)
  (let ((u 0))
    (setf (ldb (byte 8 8) u) (aref buf 1))
    (setf (ldb (byte 8 0) u) (aref buf 0))
    u))

################################################################################

https://www.reddit.com/r/lisp/comments/9q68y8/has_the_gnu_coreutils_ever_been_implemented_in/
https://www.reddit.com/r/lisp/comments/1fj0qf/lisp_vs_haskell/
https://github.com/BusFactor1Inc/sxc
https://news.ycombinator.com/item?id=13199610
https://www.cliki.net/cl-emacs
https://nullprogram.com/blog/2014/06/29/
https://mattdesl.svbtle.com/drawing-lines-is-hard
http://www.osenkov.com/diplom/contents/1/4/
https://github.com/sile/taomp-sbcl
http://etodd.io/2016/01/12/poor-mans-threading-architecture/
https://www.pvk.ca/Blog/2013/04/13/starting-to-hack-on-sbcl/
http://web.media.mit.edu/~lieber/Lieberary/GC/Realtime/Realtime.html

########################################################################

Separate parts become a whole when it is more efficient to do so or
when the interaction of those separate parts becomes more complex than
those parts as a whole.

########################################################################

http://wiki.c2.com/?SingleAddressSpaceOperatingSystem
https://www.usenix.org/legacy/event/usenix99/full_papers/deller/deller.pdf
https://news.ycombinator.com/item?id=11187072
http://www.lighterra.com/papers/modernmicroprocessors/

coupling is like number of edges between two given areas
cohesion is like number of nodes in a given area

ZERO FRAGMENTATION HEAP -> LINEAR HEAP
https://library.softwareverify.com/memory-fragmentation-your-worst-nightmare/

################################################################################

https://emersion.fr/blog/2018/wayland-rendering-loop/
https://stackoverflow.com/questions/17717600/confusion-between-c-and-opengl-matrix-order-row-major-vs-column-major

9.005 Are OpenGL matrices column-major or row-major?

For programming purposes, OpenGL matrices are 16-value arrays with base vectors laid out contiguously in memory. The translation components occupy the 13th, 14th, and 15th elements of the 16-element matrix, where indices are numbered from 1 to 16 as described in section 2.11.2 of the OpenGL 2.1 Specification.

Column-major versus row-major is purely a notational convention. Note that post-multiplying with column-major matrices produces the same result as pre-multiplying with row-major matrices. The OpenGL Specification and the OpenGL Reference Manual both use column-major notation. You can use any notation, as long as it's clearly stated.

Sadly, the use of column-major format in the spec and blue book has resulted in endless confusion in the OpenGL programming community. Column-major notation suggests that matrices are not laid out in memory as a programmer would expect.


################################################################################

Each vertex has either a texture or a pixel (no texture)

################################################################################


: "X"
-> "X"
:
: (struct (+ (>> -4 (adr '"X")) 0) '(B . 16))
-> (130 5 0 0 0 0 0 0 40 203 209 14 180 127 0 0)

-So CAR and CDR are two different pointers
 ...which is probably two instances of the name then...

 Trans symbol
 - name stored directly in car/left
 - right changes with value, however, it is not nil
 - initially it is not the same as name
   -> name may be contained in another cell

:
: (struct (- (>> -4 (adr "X")) 0) '(B . 16))
-> (130 5 0 0 0 0 0 0 216 221 163 76 236 127 0 0)
:
: (struct 140652874816984 '(B . 16))
-> (216 221 163 76 236 127 0 0 216 221 163 76 236 127 0 0)
:


: (struct (- (>> -4 (adr (box))) 0) '(B . 16))
-> (2 0 0 0 0 0 0 0 72 215 66 0 0 0 0 0)
: (struct (- (>> -4 (adr (box 1))) 0) '(B . 16))
-> (2 0 0 0 0 0 0 0 18 0 0 0 0 0 0 0)
: (struct (- (>> -4 (adr (box 0))) 0) '(B . 16))
-> (2 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0)

Anon Symbol:
CAR:  0
CDR: NIL

Transient Symbol:
CAR: name (if name > 7 characters, then ptr to cons cell)
CDR: pointer to CDR of itself (points to symbol)

So CDR points to a cell which points to itself

[name|ptrVAL] ->

How to represent numbers...


ASCII = Character
Number = Character

Alt+ASCII = Type Num
Alt+Number = Type Num

Shift+Enter/Tab = Read
Ctrl+Enter/Tab = Eval

################################################################################

https://news.ycombinator.com/item?id=9981874
https://www.bfilipek.com/2015/01/persistent-mapped-buffers-benchmark.html
https://stackoverflow.com/questions/2963898/faster-alternative-to-memcpy

################################################################################

#{
https://gavv.github.io/articles/unix-socket-reuse/

A socket file is created by bind(2) call.
If the file already exists, EADDRINUSE is returned.

Unlike Internet sockets (AF_INET), Unix domain sockets (AF_UNIX) doesn’t have
SO_REUSEADDR, at least on Linux and BSD. The only way to reuse a socket file
is to remove it with unlink().

There are two bad approaches to deal with this problem:

#1

We could call unlink() just before bind().

The problem is that if we run two instances of our process, the second one will silently remove socket used by the first one, instead of reporting a failure.

Also, there is a race here since the socket can be created by another process between unlink() and bind().

We could call unlink() when the process exits instead.

The problem is that if our process crashes, unlink() will not be called and we’ll have a dangling socket.

#2

Using a lock file

One option is to use a lock file in addition to the socket file.

We’ll use a separate lock file and never call unlink() on it. When a process is going to bind a socket, it first tries to acquire a lock:

If the lock can’t be acquired, it means that another process is holding the lock now, because kernel guarantees that the lock is released if owner process exits or crashes.

If the lock is successfully acquired, we can safely unlink() the socket, because we’re the only owner and no race may occur.

#3
Using abstract namespace sockets

Another option is to use Linux-specific abstract namespace sockets.

To create an abstract namespace socket, set the first byte in the sun_path field of the sockaddr_un to \0. See unix(7). This socket will not be mapped to the filesystem, so it’s not possible to use filesystem permissions or remove it with unlink().

The advantage is that such a socket is automatically removed when the process exits, so there is no problem with socket reusing.

}#


################################################################################

https://datenwolf.net/bl20110930-0001/

My dream graphics system was completely abstract. Creating a window didn't involve selecting visual formats, framebuffer configurations. It was just "a window". Only when actual content is involved I want to tell the rendering subsystem, which color space I use. Ideally all applications worked in a contact color space (e.g. CIE XYZ or Lab), but sending images in some arbitrary color space, together with color profile information. Fonts/Glyphs would be rendered by some layer close to the hardware, to carefully adjust the rasterizing to the output devices properties. And last but not least the whole system should be distributed. Being able to "push" some window from one machine's display, to another machine's (and this action triggering a process migration) would be pinnacle. Imagine you begin writing an email on your smartphone, but you realize you'd prefer using a "usable" keyboard. Instead of saving a draft, closing the mail editor on the phone, transferring the draft to the PC, opening it, editing it there. Imaging you'd simply hold your smartphone besides your PC's monitor a NFC (near field communication) system in phone and monitor detects the relative position, and flick the email editor over to the PC allowing you to continue your edit there. Now imagine that this happens absolutely transparent to the programs involved, that this is something managed by the operating system.

http://blog.rongarret.info/2015/05/why-lisp.html
http://blog.rongarret.info/2006/10/top-ten-geek-business-myths.html
http://xahlee.info/UnixResource_dir/writ/lisp_problems.html

Confusing
Lisp's irregular syntax are practically confusing. For example, the difference between (list 1 2 3), '(1 2 3), (quote (1 2 3)) is a frequently asked question. The use of ` , ,@ are esoteric. If all these semantics use the regular syntactical form (f args), then much confusion will be reduced and people will understand and use these features better. For example:

(a . b) ; bad

(. a b) ; good
'(1 2 3) ; bad

(' 1 2 3) ; good
; or
(list-literal 1 2 3) ; good
(setq myListXY `(,@ myListX ,@ myListY)) ; bad

(setq myListXY (` (,@ myListX) (,@ myListY))) ; good
; or
(setq myListXY (eval-parts (splice myListX) (splice myListY))) ; good


Deep Nesting is Rare
The lisp's cons, as a underlying primitive that builds lists, even though a bit cumbersome, but works just fine when data structure used is simple. Even today, with all the Perl, Python, PHP, JavaScript etc langs that deal with lists, vast majority of list usage is just simple flat list, sometimes 2 level of nesting (list of list, list of hash, hash of list). 3 levels of nesting is seldom used, unless it is 3D matrices used mostly in computer graphics or linear algebra applications. Greater than 3 level is rarely seen. Systematic manipulation and exploitation of nested list, such as mapping to leafs, to particular level, transposition by permutation on level, or list structure pattern matching in today's functional langs, etc is hardly ever to be seen. (These are common idioms in so-called array languages. For example, APL, MATLAB, Mathematica.)

So, in general, when you just deal with simple lists, the cumbersomeness of using {cons, car, cdr, caardr, …} for list doesn't really surface. Further, the cons is fundamentally rooted in the language. It's not something that can be easily changed except creating a new language. When there is a specific need in a application, there is a haphazard collection of functions that deal with lists at a higher level.

KIND OF LIKE POINTERS, EH?

=======================

https://www.khronos.org/registry/OpenGL-Refpages/es3.0/html/glGetProgramBinary.xhtml
https://linux.slashdot.org/story/19/05/15/1523252/why-linux-on-desktop-failed-a-discussion-with-mark-shuttleworth?sdsrc=popbyskidbtmprev
https://www.phoronix.com/forums/forum/phoronix/latest-phoronix-articles/1114417-wayland-s-weston-lands-a-pipewire-plug-in-as-new-remote-desktop-streaming-option/page3

Wayland and X11 are two very different things and remote desktop is one area where Wayland will always still benefit from a protocol such as X11. For example the best Wayland can do is a slow VNC type approach of sending across a complete raster image (albeit compressed) which requires a lot of bandwidth. An intelligent protocol sends across instructions such as "draw line between x and y". This is how X11 works.

Windows and RDP has even X11 beaten and is thus far ahead of VNC and Wayland when it comes to performance. This is because rather than simply sending drawing instructions, it is aware of widgets and so can send much higher level instructions such as "refresh window", "draw button here", etc.

In short... The *NIX desktop (*NOT Wayland*) needs to up its game if it plans on ever competing in the enterprise with remote desktop solutions again. This needs to be done from the widget toolkit (such as Qt or GTK+), not the underlying platform and certainly not a compositor. Something like this:

Unfortunately due to a very immature Wayland, the Linux desktop is now extremely behind and is at risk of re-entering the "hobbiest / toy" market.


################################################################################

https://www.mail-archive.com/picolisp@software-lab.de/msg07414.html

On Wed, May 03, 2017 at 10:24:59AM -0800, Christopher Howard wrote:
> Just out of curiosity: does PicoLisp have some mechanism for dumping the
> process image (or some equivalent effect) so you can save a PicoLisp
> process in a certain state and restart it there.


Not completely I think. What comes close would be pretty-printing the values of
all symbols (omitting circular structures which otherwise would cause a hang):

   (out "save.l"
      (for "S" (all)
         (unless (circ? (val "S"))
            (pp "S") ) ) )


On Wed, May 03, 2017 at 09:18:22PM +0200, Alexander Burger wrote:
> On Wed, May 03, 2017 at 10:24:59AM -0800, Christopher Howard wrote:
> > Just out of curiosity: does PicoLisp have some mechanism for dumping the
> > process image (or some equivalent effect) so you can save a PicoLisp
> > process in a certain state and restart it there.
>
> Not completely I think. What comes close would be pretty-printing the values
> of
> all symbols (omitting circular structures which otherwise would cause a hang):
>
>    (out "save.l"
>       (for "S" (all)
>          (unless (circ? (val "S"))
>             (pp "S") ) ) )


Having said this, I must say that I do not see a use-case.

PicoLisp starts blindingly fast by 'loadi'ng source files. And for persistence
we use the database (i.e. external symbols).

################################################################################

http://blog.rongarret.info/2006/10/top-ten-geek-business-myths.html
https://unix.stackexchange.com/questions/364641/mapping-scancodes-to-keycodes

## GC Strategies

Three primary algorithms:
* Mark...
  * Sweep
  * Region
  * Compact
* Stop/Copy (scavenging) - Cheney semi-space
* Noncopying Implicit Collection - Baker
  * Has advantages of both Mark + Stop/Copy
  * Main weakness is fragmentation...but not an issue for PicoLisp?

Mark/sweep is faster when low mortality/high liveliness since less
sweeping is done.

Stop/copy is faster when high mortality/low liveliness due to copying
all live objects.

Mark/sweep uses less space than stop/copy since stop/copy always
reserves half of the space.

Larger objects favor mark/sweep than stop/copying.

Stop/copy defragments by compacting data through copying.

Stop/copy running time proportional to amount of live objects, not the
size of the heap.

Stop/copy provides better worst-case space bounds than noncopying.

In PicoLisp, since everything is a cons cell, the GC can be optimized
around that, which favors stop/copy.

https://www.quora.com/Which-type-of-garbage-collection-mechanism-is-more-efficient-mark-sweep-or-stop-copy
https://www.hboehm.info/gc/complexity.html

Give user option:
- Expand heap
  - Can only expand until run out of memory
- Collect heap
- Fork+Collect heap
  - User must do side-effect free operations until

## RESEARCH

https://www.youtube.com/watch?v=R7EEoWg6Ekk
https://academia.stackexchange.com/questions/109/is-there-any-efficient-non-linear-note-taking-software
http://doc.rix.si/cce/cce.html

Biggest emacs issues:
1. Concurrency - operations/fns locking up interactiveness
2. C Core

Javascript Engines
1. QuickJS
2. ducktape
3. Jsish

https://news.ycombinator.com/item?id=20411154

################################################################################

We can create screens...but make them nodes also

https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/

Should write down cases and use as tutorials/examples

################################################################################

https://www.mail-archive.com/picolisp@software-lab.de/msg07287.html

> (list (box) (box) (box))
> ...
> ($177760526373112 $177760526373114 $177760526373116)


> Where each memory location is two more than the previous. I am wondering

Yes. BTW, these are actually cell addresses, not bytes. The values have to be
multiplied by 16 to get the physical addresses. And the value is printed in
octal representation.

Two cell are created for each symbol here, one for the symbol itself and one for
the list being built.


> if this behavior is guaranteed to always be the case, the implication

The observed offset of two is not guaranteed. Cells are picked sequentially from
the heap in the beginning, but from the Avail list after garbage collection, and
are not predictable.


> being one could have random access to any cell provided he knew the
> address of the first cell.

Correct. There is even a function for that, 'adr':

   : (box)
   -> $377166006651

   : (adr @)
   -> -34256457129

   : (oct @)
   -> "-377166006651"


  #{

      1. (X) . (()   Fn))
      2. (X) . (Ctrl Fn))

      Problem! -> 1 is always found first so 2 never executes

      Bitmask?

      1. (X) . ( (()   Fn)
                 (Ctrl Fn)
                 (Alt Fn)
                 (Shift Fn) )

      Hold Ctrl, Press X

      1. assoc ctrl -> no exist
      2. assoc x    -> list exist, assoc x list, check times
  }#


(+ 1 2)
"(+ 1 2)"
+ 1 2

+
Intern
1
2
Eval


https://www.osnews.com/story/18829/pt-i-spatial-memory/

################################################################################

http://www.cs.umd.edu/hcil/treemap-history/

################################################################################

https://news.ycombinator.com/item?id=15466124
https://news.ycombinator.com/item?id=1878220


 sedachv on Nov 7, 2010 [-]

Lisp Machines are something that you think is really cool when you first learn about them, then you come to the realization that pining for them is a waste of time.

I've had a flash of inspiration recently and have been thinking about Lisp Machines a lot in the past three weeks.

But first, a digression. There's an important lesson to be learned about why Symbolics failed. I think Richard Gabriel came to the completely wrong conclusion with "Worse is Better" (http://www.dreamsongs.com/WorseIsBetter.html). There are two reasons why:

1. Out of all the LispM-era Lisp hackers, only RMS understood the value of what's now known as Free Software. (If you haven't read it yet, read Steven Levy's Hackers - it describes the MIT/LMI/Symbolics split and how RMS came to start FSF and GNU).

2. Portability is really important.

The key lesson to draw from Unix isn't that "Worse is Better," it's that survivable software is Free and portable. Free because getting software to someone's harddrive is 80% of success, and portable because you don't know where people will want to use your software (there are some really weird places).

Symbolics was neither. If Genera had been Free Software, it would by definition still be around today. If Genera had been portable, it's likely Symbolics would never have gone out of business (the Alpha virtual machine would have been done sooner, with less resources, and for more systems).

Being released as Free Software today wouldn't help. Genera's predecessor, MIT CADR, was made available under an MIT-style license in 2004 (http://www.heeltoe.com/retro/mit/mit_cadr_lmss.html). There's a VM emulator which runs the code. The whole system is pretty useless.

Now on to the inspiration part:

It's possible to make a very high-performance, portable Lisp operating system on modern hardware. This has been a possibility ever since the Pentium came out. The main bottleneck to conventional Lisp runtime performance is the way operating systems manage memory allocation and virtual memory.

A type-safe runtime that has control over memory layout, virtual memory, and is aware of DMA can provide extremely high throughput for allocation and GC (this has been shown by Azure's Linux patches for their JVM), true zero-copy I/O, almost optimal levels of fragmentation, and excellent locality properties. If you go single address space (and there's no reason not to) and move paging into software (object faulting and specialized array access), you've also eliminated TLB misses.

Throw in the fact that it now becomes trivial to do exokernel-type stuff like for example caching pre-formatted IP packets, and it should be possible to build network servers that have throughput many times that of anything that kernel/user-space split OSes like Linux or FreeBSD are capable of for dynamic content (ie - not just issuing DMA requests from one device to another).

The only problem is device drivers. Lisp doesn't make writing device drivers any more fun, or reduce the number of devices you have to support.

What to do?

The reason I've been thinking about this is that I came across this: http://www.cliki.net/Zeta-C

I've heard of Zeta-C multiple times before, but for some reason this time I made the connection - "why not use Zeta-C to compile an OS kernel?"

I explored the idea further, and it seems to me that it wouldn't be an unreasonable amount of work to take the NetBSD device subsystem and have it running on top of a Lisp runtime with the necessary emulation of those parts of the NetBSD kernel that the drivers depend on. If you don't know, NetBSD's device drivers are modular - they're written on top of bus abstraction layers, which are written on top of other abstraction layers (for example, memory-mapped vs port I/O is abstracted). So the actual system twiddling bits can be neatly encapsulated (which isn't necessarily true for Linux drivers, for example).

I'm aware of Movitz (http://common-lisp.net/project/movitz/) and LoperOS (http://www.loper-os.org/). Movitz makes the mistake of trying not to be portable, but there's useful things there. I haven't spoken to Slava about this yet so I don't know what's going on with LoperOS. I am also aware of TUNES, and think it was an interesting waste of time.

The main thing is to get Zeta-C to work on Common Lisp. Then it's to build a new portable, boot-strappable runtime (I think the Portable Standard Lisp approach of having a SYSLISP layered on top of VOPs is the right way to go for this), and either build a compiler targeting that runtime, or adapt the IR-generating parts of one of SBCL, CMUCL or Clozure. Further bootstrapping can be done with SWANK and X11 once a basic networking stack is in place. I think such a system would be quite fun to hack on.

If you've gotten this far, let me know what you think about this idea. I also have some preliminary thoughts about how this can be worked into the base of a new high-performance/scalability transactional database startup, if you want to hear about that email me: vsedach@gmail.com

########################################################################

cryptorick
KVMap.l

KEY FEATURES FOR NOTE-TAKING/PERSONAL KNOWLEDGE DATABASE
* Local
* Search
* Sync
* Web Clipper
* ScanTailor
* Collaboration
* Native - wait for pil21; until then, create web version
* Export data to plaintext, PDF, Markdown, ODF/ODT

* PDF/Markdown/RSS

https://news.ycombinator.com/item?id=19552221
If you practice GTD like me, you need a trusted repository for capturing
   your thoughts, items, todos, etc. It should be fast and easy and available
   everywhere. Thats The value prop that EN brings to the table. No matter
   what it is you want to capture and store, no matter what platform, they
   have a way to quickly and easily do it. You can even email notes right into
   it (they give you a special email address) which I use for things like tech
   newsletters and stuff. So while you are right that notes apps have been
   around, its the little things that really make the difference here.

TODO: Matrix for Competition Pricing

Smartphones are diverging in functionality?

https://itnext.io/why-are-we-creating-a-javascript-only-world-wide-web-db8c3a340b9

obj distribution
https://www.mail-archive.com/picolisp@software-lab.de/msg03305.html

################################
################################

Reality is just a convenient measure of complexity
-alvy ray smith

===============

The Sad State of Personal Knowledge Bases

So all knowledge can be seen as connected,
but all knowledge can also be put into hierarchies.
Concepts and how those concepts are related is something that people come up with,
rather than being an inherent property of the universe.

The idea of forcing yourself to put knowledge into hierarchies is that it makes your thinking more clear,
makes it easier to remember where things are,
and perhaps paradoxically makes it easier to see how things are related.
(Or at least highlights certain types of relationships
that are only visible in the context of hierarchies.)

I'll admit it's pretty weird at first to only get one root node,
I think it took me a couple years to get used to that.
But once I embraced it the benefits quickly became clear.


It is not about store and searching information but
having ways to structure and visualize it


Tags speed up searches by avoiding full text

(find-tag these are some words)
(find-tag (these are some words))

OR = find at least one of the tags
AND = find all of the tags
FIL = filter left to right

To automake tags, ignore common words

Build DSL for it

Test DB up to 50 GB

Build different data structures to simulate
YT, IG, FB, BLOGs, TODO LISTS, GITTER/CHAT, etc.

Need to optimize/shortcut string input so users aren't constantly
packing
- auto make strings after a certain length
- if we hide the conses shouldnt be too bad
- also hide the quotes
- start string when typing, end upon mod+Enter or mod+Space
- or time-based, if user stops typing string is automatically made
  - make sense with stop and go thinking


=======================

https://news.ycombinator.com/item?id=17892731

Improving SDF at smaller sizes

http://www.java-gaming.org/topics/solved-signed-distance-field-fonts-look-crappy-at-small-pt-sizes/33612/view.html

https://www.essentialmath.com/blog/?p=151

https://discourse.libcinder.org/t/cinder-sdftext-initial-release-wip/171/14


===========================================================================

(zap 'sym) -> sym
"Delete" the symbol sym. For internal symbols, that means to remove it from the
current namespace, effectively transforming it to a transient symbol. For
external symbols, it means to mark it as "deleted", so that upon a later commit
it will be removed from the database file. See also intern.
========================================
-> zap
: (setq L (list 'a 'b 'c))
-> (a b c)
: L
-> (a b c)
: (setq A 1 B 2 C 3)
-> 3
: L
-> (a b c)
: (zap 'a)
-> "a"
: L
-> ("a" b c)


https://www.mail-archive.com/picolisp@software-lab.de/msg07287.html

> (list (box) (box) (box))
> ...
> ($177760526373112 $177760526373114 $177760526373116)


> Where each memory location is two more than the previous. I am wondering

Yes. BTW, these are actually cell addresses, not bytes. The values have to be
multiplied by 16 to get the physical addresses. And the value is printed in
octal representation.

=============================================

https://news.ycombinator.com/item?id=18958046

For me it was efficiency of reading. It is proven that proportional, serif fonts read significantly faster (17%) [1] or [2] (6.1%). Also, in my opinion, scanning is much faster.

This makes sense: our eye uses the top and bottom of words to ‘key’ the word. Use proportional and you add information to this system.

[1] https://blog.codinghorror.com/comparing-font-legibility/

[2] https://journals.sagepub.com/doi/pdf/10.1177/001872088302500...

(edit: add references to research)

If drawn after ptr, ptr is above
If drawn before ptr, ptr is under

So draw non-ptrs first
Then draw ptrs after

https://graphicdesign.stackexchange.com/questions/5650/do-all-monospace-sans-serif-fonts-look-the-same

http://s9w.github.io/font_compare/

systemE -> sinit ->
sinit is a suckless init, initially based on Rich Felker's minimal init.

https://superuser.com/questions/320529/how-to-create-a-linux-system-that-runs-a-single-application/991733#991733

https://www.phoronix.com/forums/forum/phoronix/general-discussion/40672-richard-stallman-calls-llvm-a-terrible-setback/page16

https://news.ycombinator.com/item?id=19797152

Can anyone suggest interesting work that is kind of the opposite of this? Vast real estate, rich HIDs, dynamic autonomous presentation?

So focused on many/big screens, with an eye towards future high-res AR/VR 3D, rather than a single "space is precious" small screen. Rich human interface devices, like multitouch and 3D hand pose and stylus and head position and gaze, rather than a single mouse. Display as a dynamic ecosystem of presentations, under the influence of multiple agents, rather than detailed manual control. UI as collaborative improv dance, rather than as micromanagement.

Punchcards and console toggles; teletype printer; VT100 terminal; small bitmapped monitor and mouse; larger monitor; largerer monitor; largererer; multiple monitors; with multitouch and stylus tablet; future high-res AR/VR... as tech so very slowly becomes less crippling, the UIs do too...

Hmm, though for current VR, with its 1980's VGA-like non-blurry pixels are more precious than they've been for decades, fine-grained control and space sharing might be quite nice?

https://en.wikipedia.org/wiki/AoS_and_SoA

https://github.com/pel-daniel/mind-bicycles

=============================================


https://news.ycombinator.com/item?id=19746122

Summary:

- We don't need separate processes if the language we use is inherently safe (e.g., modern Common Lisp).

- Without process isolation, it is possible to share large, complicated and possibly mutable data structures (graphs, arrays, user-defined objects) system-wide.

- Once it is possible to cheaply share and communicate arbitrary data structures, it is pointless to maintain designated 'file system'.

- Not having a file system raises the question of what data should be persistent and what shouldn't. But on a modern computer, it is feasible to just treat all data as persistent (maybe excluding the youngest GC generation).

The best news is that the author is actually working hard to implement this operating system. The first part - the Lisp implementation - is already in a pretty good shape and could be finished within the next two years: https://github.com/robert-strandh/SICL


=================================

buffered gc:
https://www.jstage.jst.go.jp/article/ipsjjip/27/0/27_479/_pdf


https://github.com/status-im/nimbus/wiki/Interpreter-optimization-resources

hash fns
https://gist.github.com/badboy/6267743

https://stackoverflow.com/questions/664014/what-integer-hash-function-are-good-that-accepts-an-integer-hash-key


Positions never overlap so can use positions as keys
then do range search


==============================

if we use a class
how to draw obj with properties?

                                                                                      Symbol
                                                                                        |
                                                                                        V
    +----------+---------+     +-----+-----+     +-----+-----+     +-----+--+--+     +-----+-----+
    |'hgfedcba'|'onmlkji'| <---+  |  |     | <---+ KEY |     | <---+  |  |  |  | <---+  |  | VAL +
    +----------+---------+     +--+--+-----+     +-----+-----+     +--+--+-----+     +--+--+-----+
                                  |                                   |
                                  V                                   V
                                  +-----+-----+                       +-----+-----+
                                  | VAL | KEY |                       | VAL | KEY |
                                  +-----+-----+                       +-----+-----+

    (n (k1 (v1)) (k2) (k1 (v1)) s)



    condense, or hide cells:


    +----------+---------+            +-----+-----+            +-----+-----+
    |'hgfedcba'|'onmlkji'| <--- C <---+ KEY |     | <--- C <---+  |  | VAL +
    +----------+---------+            +-----+-----+            +--+--+-----+

    use dot with special color - red?
    -> uses particle principles - symbol to represent a cell


https://www.reddit.com/r/vexillology/comments/7dxjme/flag_of_the_grid_tron_legacy/

min components needed within lisp userspace
* wayland
  * web browser
  * libreoffice

intersection of pp, excel, hypercard, vim, and emacs
and opendoc

METAPHOR is KEY

https://news.ycombinator.com/item?id=27979399

The hard bit I think is the "spaghetti no-code" problem that I've seen in nearly all visual-type programing environments. Just because it's no code, all of the logic still needs to exist somewhere. When we code we can break it apart in many ways, and how you break things apart and abstract things depends on the system.

But no-code tools are fixed, and you only have one way to divide up the logic. In Bubble's case, it means there's a "design" section with UI and data-binding, and a "workflow" section with all of the actions that happen: UI interactions and business logic are smooshed in together. You end up with thousands of boxes indicating actions, in a giant list. You can kind of group them, and you can colourize them - but everything is held together by convention. A single logical flow can require many UI elements, and tracking that logical flow through the various unrelated boxes is... spaghetti!

In Structure and Interpretation of Computer Programs it says "Every powerful language has three mechanisms for [combining simple ideas to form more complex ideas]:

* primitive expressions, which represent the simplest entities the language is concerned with,
-> lists, atoms (symbols and numbers)
-> eval, read

* means of combination, by which compound elements are built from simpler ones, and
-> lists of atoms
-> symbols' property lists can point to lists or atoms etc

* means of abstraction, by which compound elements can be named and manipulated as units."
-> namespace/symbols (both literal and programmatic/syntax-wise)
  -> symbols are how humans abstract ideas
    -> most basic is numbers

a visual language should have the same properties
most of them miss the 3rd principle of abstraction
e.g cant take multiple nodes as a single unit
differentiate vertical vs horizontal abstraction?
-> organization vs abstraction
what did hypercard do?

music notation...abstraction
example...loud/soft when pressing a key or chords

DSLs are a means of abstraction
they are not compound
a list is compound
or it is a compund of functions like eval read
primitive objects in a dsl abstract compound elements

hypercard: a visual language has a card and objects on it
which can have properties

cards can inherit from other cards
transclusion

https://medium.com/@modernserf/the-origin-of-hypercard-in-the-breakdown-of-the-bicycle-for-the-mind-8d0f3287e561

excel = spreadsheet of cells
hypercard = stack of cards
pp = slides of objects/widgets
vim = lines of words
emacs = gap buffers/arrays of bytes/chars
  -> gap buffers have no real life presentation - mostly abstract
lisp = cons cells of cons cells
        essentially a tree structure
        or simply the outline metaphor like notes
        HYPERTREE

WHAT DID HYPERCARD DO THAT WAS SPECIAL??

=========================================

https://www.reddit.com/r/lisp/comments/22lbpe/whatever_became_of_clim/
https://groups.google.com/g/comp.lang.lisp/c/XpvUwF2xKbk/m/o6CKxgzNLFUJ
https://groups.google.com/g/comp.lang.lisp/c/XpvUwF2xKbk/m/Xz4Mww0ZwLIJ

Independent of CLIM or McCLIM per se, I think that the paradigm of presentations is something worth keeping around.

The core of it is: there is a single mechanism in which associations between objects (value, etc.) represented in the user interface by widgets (view, component, graphic, element, etc.) are stored, so that commands and other interactions can be defined on the object type, once independently of the specific visual representation being used.

This differs from "data binding" by exposing the domain objects, not just data, and therefore introducing the notion of commands operating on the objects.

This differs from "naked objects" (generating UI from domain objects) by admitting different UI representations of the same object.

NOTES:
we impose constraints on top of clims presentation types
and simplify the relationship by using picolisp
and the idea of hypercard

- we restrict semantic associations to the cons cell (underyling PicoLisp)
  - cannot abstractly go any lower except to raw pointer/memory addresses like asm
  - physically cells can be freely placed or within a list structure
  - restrict overlap? (for drawing reasons, make transparency explicit?)
- instead of widgets we use symbols mapped to symbols (underyling PicoLisp)
  - representation maps to GPU data structures which is a black box itself...
- structure is provided as a binary tree (underyling PicoLisp)
- if interactions are defined on underlying type,
  how does the user now what interactions they can do??

lisp machine allows ad hoc solutions
we provide the infrastructure to share it
one single command or click to share it
like git for lisp objects

we tie all these concepts together
and present it in the market
in a way, users can understand it

traditional UIs are changing
and more people are looking for alternatives
now is the time to strike

icons = code = data

====================

clim is almost there
it ties the presentation of an object to an underyling semantic model
likely not popular because it is tied to lisp
and established metaphors by windows
implementing it in another language would not yield the same benefits?
  or the interactions are hard coded in conventional programs
  the dynamicness is only helpful for what? html/js/css/wasm handles dynamic guis...
  why hypercard creator laments not building in networking...
  so whats livecode doing wrong? -> more of a PL/divergent/industrial tool than artistic/exploratory/experimental tool
it contains all the mechanisms but no discovery
same issue with emacs...lispers expect it to be self-discovering

McCLIM -> Symbolics Open Genera's Dynamic Windows


http://www.lichteblau.com/blubba/font-selector/mcclim/What-is-a-presentation-type.html

4.1 What is a presentation type

The concept of presentation types is central to CLIM. Client code can choose to output graphical or textual representations of application objects either as just graphics or text, or to associate such output with an arbitrary Common Lisp object and a presentation type. The presentation type is not necessarily related to the idea Common Lisp might have of the underlying object.

When a CLIM command or some other client code requests an object (say as an argument) of a certain presentation type, the user of the application can satisfy the request by clicking on any visible output labeled with a compatible presentation type. The command then receives the underlying Common Lisp object as a response to the request.

CLIM presentation types are usually distinct from Common Lisp types. The reason is that the Common Lisp type system, although very powerful, is not quite powerful enough to represent the kind of relationships between types that are required by CLIM. However, every Common Lisp class (except the built-in classes) is automatically a presentation type.

A presentation type has a name, but can also have one or more parameters. Parameters of presentation types are typically used to restrict the type. For instance, the presentation type integer takes as parameters the low and the high values of an interval. Such parameters allow the application to restrict objects that become clickable in certain contexts, for instance if a date in the month of March is requested, only integers between 1 and 31 should be clickable.


https://github.com/McCLIM/McCLIM

McCLIM, an implementation of the "Common Lisp Interface Manager CLIM II Specification", is a portable and high-level user interface management system toolkit for Common Lisp. It has a powerful presentation model which allows us to directly link the visual representation of an object to its semantics. It has several high-level programming capabilities that enable us to develop a user interface conveniently; including formatted output, graphics, windowing and commands that are invoked by typing text, keyboard shortcuts or clicking a mouse button.

=========
instead of our complicated system
have repr match nested lists

((a b c)
 (d e f)
 (g h i))

select whitespace to make a list?
creates hidden ptr state?

============================================
============================================

https://news.ycombinator.com/item?id=20191406

https://no-kill-switch.ghost.io/the-rise-of-personal-knowledge-management-tools/

https://news.ycombinator.com/item?id=9831429

https://news.ycombinator.com/item?id=7878679

https://hn.algolia.com/?dateRange=all&page=0&prefix=true&query=lisp%20failed&sort=byDate&type=all

https://news.ycombinator.com/item?id=22580884

# UI and software profession
https://news.ycombinator.com/item?id=22901541

https://no-kill-switch.ghost.io/the-rise-of-personal-knowledge-management-tools/
